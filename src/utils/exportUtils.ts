import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import Papa from 'papaparse';
import * as XLSX from 'xlsx';

export interface ExportData {
  reportName: string;
  schoolName?: string;
  dateGenerated: string;
  metrics: {
    label: string;
    value: string | number;
  }[];
  tables: {
    title: string;
    headers: string[];
    rows: (string | number)[][];
  }[];
  sections?: {
    title: string;
    content: string;
  }[];
}

/**
 * Export report as PDF
 */
export async function exportToPDF(data: ExportData): Promise<void> {
  const doc = new jsPDF({
    orientation: 'landscape',
    unit: 'mm',
    format: 'a4',
  });

  let yPosition = 20;

  // Header
  doc.setFontSize(20);
  doc.setTextColor(23, 112, 192); // #1770C0
  doc.text(data.reportName, 15, yPosition);
  yPosition += 8;

  // Subheader
  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  if (data.schoolName) {
    doc.text(`School: ${data.schoolName}`, 15, yPosition);
    yPosition += 6;
  }
  doc.text(`Generated: ${data.dateGenerated}`, 15, yPosition);
  yPosition += 10;

  // Key Metrics
  if (data.metrics && data.metrics.length > 0) {
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 0);
    doc.text('Key Metrics', 15, yPosition);
    yPosition += 8;

    const metricsData = data.metrics.map(m => [m.label, String(m.value)]);
    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: metricsData,
      theme: 'grid',
      headStyles: { fillColor: [23, 112, 192], textColor: [255, 255, 255] },
      margin: { left: 15 },
    });
    yPosition = (doc as any).lastAutoTable.finalY + 10;
  }

  // Tables
  if (data.tables && data.tables.length > 0) {
    for (const table of data.tables) {
      // Check if we need a new page
      if (yPosition > 180) {
        doc.addPage();
        yPosition = 20;
      }

      doc.setFontSize(14);
      doc.setTextColor(0, 0, 0);
      doc.text(table.title, 15, yPosition);
      yPosition += 8;

      autoTable(doc, {
        startY: yPosition,
        head: [table.headers],
        body: table.rows,
        theme: 'striped',
        headStyles: { fillColor: [23, 112, 192], textColor: [255, 255, 255] },
        alternateRowStyles: { fillColor: [240, 240, 240] },
        margin: { left: 15 },
      });
      yPosition = (doc as any).lastAutoTable.finalY + 10;
    }
  }

  // Footer on each page
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(
      `Page ${i} of ${pageCount} â€¢ Generated by Playfly`,
      doc.internal.pageSize.width / 2,
      doc.internal.pageSize.height - 10,
      { align: 'center' }
    );
  }

  // Download
  const fileName = `Playfly_${data.reportName.replace(/\s+/g, '_')}_${data.schoolName?.replace(/\s+/g, '_') || 'Network'}_${new Date().toISOString().split('T')[0]}.pdf`;
  doc.save(fileName);
}

/**
 * Export report as CSV (multiple files in a ZIP)
 */
export async function exportToCSV(data: ExportData): Promise<void> {
  if (!data.tables || data.tables.length === 0) {
    throw new Error('No table data available for CSV export');
  }

  // For simplicity, export the first table as CSV
  // In production, you'd create a ZIP with multiple CSVs
  const table = data.tables[0];
  const csvData = [table.headers, ...table.rows];
  const csv = Papa.unparse(csvData);

  // Download CSV
  const fileName = `Playfly_${data.reportName.replace(/\s+/g, '_')}_${table.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName;
  link.click();
  URL.revokeObjectURL(link.href);
}

/**
 * Export report as Excel
 */
export async function exportToExcel(data: ExportData): Promise<void> {
  const workbook = XLSX.utils.book_new();

  // Summary Sheet
  const summaryData: any[][] = [
    ['Report', data.reportName],
    ['Generated', data.dateGenerated],
  ];
  if (data.schoolName) {
    summaryData.push(['School', data.schoolName]);
  }
  summaryData.push([], ['Key Metrics'], []);

  if (data.metrics && data.metrics.length > 0) {
    summaryData.push(['Metric', 'Value']);
    data.metrics.forEach(m => {
      summaryData.push([m.label, m.value]);
    });
  }

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
  // Set column widths
  summarySheet['!cols'] = [{ wch: 30 }, { wch: 20 }];
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

  // Data Sheets
  if (data.tables && data.tables.length > 0) {
    data.tables.forEach((table) => {
      const tableData = [table.headers, ...table.rows];
      const sheet = XLSX.utils.aoa_to_sheet(tableData);

      // Set column widths based on content
      const colWidths = table.headers.map((_, colIndex) => {
        const maxLength = Math.max(
          table.headers[colIndex]?.toString().length || 0,
          ...table.rows.map(row => row[colIndex]?.toString().length || 0)
        );
        return { wch: Math.min(maxLength + 2, 50) };
      });
      sheet['!cols'] = colWidths;

      const sheetName = table.title.substring(0, 31); // Excel sheet name limit
      XLSX.utils.book_append_sheet(workbook, sheet, sheetName);
    });
  }

  // Download
  const fileName = `Playfly_${data.reportName.replace(/\s+/g, '_')}_${data.schoolName?.replace(/\s+/g, '_') || 'Network'}_${new Date().toISOString().split('T')[0]}.xlsx`;
  XLSX.writeFile(workbook, fileName);
}
